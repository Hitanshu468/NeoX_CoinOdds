// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract GuessGame {
    // Meme Coin contract interface
    IERC20 public memeCoin;

    // Game state
    uint256 public currentNumber; // The current number generated by the contract
    mapping(address => uint256) public attempts;

    // Events for transparency
    event GameStarted(address indexed player, uint256 currentNumber);
    event BetMade(address indexed player, uint256 betAmount, string prediction, string feedback);
    event PrizeWon(address indexed player, uint256 prize);

    // Constructor: Initialize with MemeCoin contract address
    constructor(address _memeCoinAddress) {
        memeCoin = IERC20(_memeCoinAddress);
        currentNumber = uint256(block.timestamp % 100) + 1; // Initial number based on timestamp
        emit GameStarted(msg.sender, currentNumber);
    }

    // Function to claim initial tokens (100 meme coins)
    function claimInitialTokens() external {
        uint256 initialAmount = 100 * 10**18; // 100 tokens (assuming 18 decimals)
        require(memeCoin.balanceOf(address(this)) >= initialAmount, "Not enough tokens in contract");
        require(memeCoin.transfer(msg.sender, initialAmount), "Token transfer failed");
    }

    // Function to start a new game (for demonstration purposes)
    function startNewGame() external {
        // Reset the attempts for a new game (current number remains the same)
        attempts[msg.sender] = 0;
        currentNumber = uint256(block.timestamp % 100) + 1; // Generate a new current number
        emit GameStarted(msg.sender, currentNumber);
    }

    // Function to place a bet and predict whether the next number will be higher or lower
    function betOnNextNumber(uint256 betAmount, string calldata prediction) external {
        require(betAmount > 0, "Bet amount must be greater than zero");
        require(keccak256(bytes(prediction)) == keccak256(bytes("higher")) || keccak256(bytes(prediction)) == keccak256(bytes("lower")), "Prediction must be 'higher' or 'lower'");

        // Charge the player for their bet
        require(memeCoin.transferFrom(msg.sender, address(this), betAmount), "Bet payment failed");

        // Increment attempts
        attempts[msg.sender]++;

        // Generate the next random number (for simplicity, using block.timestamp or block.difficulty)
        uint256 nextNumber = uint256(block.timestamp % 100) + 1;

        // Determine if the player's prediction was correct
        bool isCorrectPrediction;
        string memory feedback;

        if ((keccak256(bytes(prediction)) == keccak256(bytes("higher")) && nextNumber > currentNumber) || 
            (keccak256(bytes(prediction)) == keccak256(bytes("lower")) && nextNumber < currentNumber)) {
            isCorrectPrediction = true;
            uint256 reward = betAmount * 2; // Double the bet amount as a reward
            require(memeCoin.transfer(msg.sender, reward), "Reward transfer failed");
            feedback = "Congratulations! Your prediction was correct!";
            emit PrizeWon(msg.sender, reward);
        } else {
            isCorrectPrediction = false;
            feedback = "Sorry, your prediction was incorrect!";
        }

        // Update the current number to the newly generated number
        currentNumber = nextNumber;

        // Emit event for transparency
        emit BetMade(msg.sender, betAmount, prediction, feedback);
    }

    // Function to view the number of attempts by a player
    function getAttempts(address player) external view returns (uint256) {
        return attempts[player];
    }
}
